name: Sync Problems from Admin Repository

on:
  workflow_dispatch:
    inputs:
      problem_name:
        description: "Name of the problem to sync"
        required: true
        type: string
      source_repo:
        description: "Source repository name"
        required: true
        type: string
      source_owner:
        description: "Source repository owner"
        required: true
        type: string
  repository_dispatch:
    types: [sync-problems]

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout web repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      - name: Install dependencies
        run: npm install

      - name: Download processed problem (recursive)
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ADMIN_REPO_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            const problemName = '${{ github.event.inputs.problem_name }}' || (github.event.client_payload && github.event.client_payload.problem_name);
            const sourceOwner = '${{ github.event.inputs.source_owner }}' || (github.event.client_payload && github.event.client_payload.source_owner);
            const sourceRepo = '${{ github.event.inputs.source_repo }}' || (github.event.client_payload && github.event.client_payload.source_repo);

            console.log(`üîÑ Syncing problem: ${problemName} from ${sourceOwner}/${sourceRepo}`);

            async function downloadDir(owner, repo, repoPath, localPath) {
              const { data: items } = await github.rest.repos.getContent({
                owner,
                repo,
                path: repoPath,
                ref: 'main'
              });

              for (const item of items) {
                if (item.type === 'file') {
                  const { data: fileContent } = await github.rest.repos.getContent({
                    owner,
                    repo,
                    path: item.path,
                    ref: 'main'
                  });
                  const fileName = path.basename(item.path);
                  const content = Buffer.from(fileContent.content, 'base64').toString('utf8');
                  if (!fs.existsSync(localPath)) fs.mkdirSync(localPath, { recursive: true });
                  fs.writeFileSync(path.join(localPath, fileName), content);
                  console.log(`üì• Downloaded: ${item.path}`);
                } else if (item.type === 'dir') {
                  const subLocalPath = path.join(localPath, item.name);
                  if (!fs.existsSync(subLocalPath)) fs.mkdirSync(subLocalPath, { recursive: true });
                  await downloadDir(owner, repo, item.path, subLocalPath);
                }
              }
            }

            try {
              const targetDir = `problems/${problemName}`;
              if (!fs.existsSync(targetDir)) fs.mkdirSync(targetDir, { recursive: true });

              await downloadDir(sourceOwner, sourceRepo, `processed-problems/${problemName}`, targetDir);

              console.log(`‚úÖ Successfully synced problem: ${problemName}`);
              execSync(`echo "PROBLEM_SYNCED=true" >> $GITHUB_ENV`);
              execSync(`echo "PROBLEM_NAME=${problemName}" >> $GITHUB_ENV`);
            } catch (error) {
              console.error(`‚ùå Error syncing problem: ${error.message}`);
              process.exit(1);
            }

      - name: Check that problem has been synced
        run: |
          echo "üß™ Checking if synced problem exists in /problems..."
          PROBLEM_NAME="${{ env.PROBLEM_NAME }}"
          if [ -d "problems/$PROBLEM_NAME" ]; then
            echo "‚úÖ Problem directory problems/$PROBLEM_NAME exists."
            ls -R "problems/$PROBLEM_NAME"
          else
            echo "‚ùå Problem directory problems/$PROBLEM_NAME does not exist!"
            exit 1
          fi

      - name: Create pull request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.BOT_PAT }}
          commit-message: "Add new problem: ${{ env.PROBLEM_NAME }}"
          title: "üÜï New Problem: ${{ env.PROBLEM_NAME }}"
          body: |
            ## üéØ New Problem Added

            **Problem:** ${{ env.PROBLEM_NAME }}
            **Source:** ${{ github.event.inputs.source_owner || github.event.client_payload.source_owner }}/${{ github.event.inputs.source_repo || github.event.client_payload.source_repo }}

            ### Changes
            - ‚úÖ Problem synced from admin repository
            - ‚úÖ Boilerplate code generated
            - ‚úÖ Test cases included
            - ‚úÖ Problem directory verified

            ### Problem Files
            - `problems/${{ env.PROBLEM_NAME }}/Problem.md` - Problem statement
            - `problems/${{ env.PROBLEM_NAME }}/Structure.md` - Problem metadata  
            - `problems/${{ env.PROBLEM_NAME }}/tests/` - Test cases
            - `problems/${{ env.PROBLEM_NAME }}/boilerplate/` - Code templates
            - `problems/${{ env.PROBLEM_NAME }}/boilerplate-full/` - Full templates

            This PR was automatically created by the problem sync workflow.

            ### Next Steps
            1. Review problem content and quality
            2. Test the problem in development environment
            3. Merge to deploy to production

            üöÄ Ready for review!
          branch: sync/problem-${{ env.PROBLEM_NAME }}
          delete-branch: true

      - name: Auto-merge if tests pass
        uses: actions/github-script@v6
        if: env.PROBLEM_SYNCED == 'true'
        with:
          github-token: ${{ secrets.BOT_PAT }}
          script: |
            const problemName = process.env.PROBLEM_NAME;
            await new Promise(resolve => setTimeout(resolve, 5000));
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `sync/problem-${problemName}`,
              state: 'open'
            });
            if (pulls.length > 0) {
              const pr = pulls[0];
              console.log(`Found PR #${pr.number} for problem ${problemName}`);
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  event: 'APPROVE',
                  body: 'ü§ñ Automated approval: Problem validation passed'
                });
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  commit_title: `Add new problem: ${problemName}`,
                  commit_message: `Automatically merged problem from admin repository`,
                  merge_method: 'squash'
                });
                console.log(`‚úÖ Successfully merged PR #${pr.number}`);
              } catch (error) {
                console.error(`‚ö†Ô∏è Auto-merge failed: ${error.message}`);
              }
            }

      - name: Notify admin repository
        uses: actions/github-script@v6
        if: always()
        with:
          github-token: ${{ secrets.ADMIN_REPO_TOKEN }}
          script: |
            const problemName = '${{ github.event.inputs.problem_name }}' || (github.event.client_payload && github.event.client_payload.problem_name);
            const success = process.env.PROBLEM_SYNCED === 'true';
            const message = success 
              ? `‚úÖ Problem **${problemName}** successfully deployed to production!`
              : `‚ùå Failed to deploy problem **${problemName}**. Check logs for details.`;
            console.log(message);
